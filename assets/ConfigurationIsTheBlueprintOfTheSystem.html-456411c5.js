import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as n,c as o,d as s,e as r,a as e}from"./app-d2084399.js";const d={},c=r('<h1 id="配置是一幅描绘系统的蓝图" tabindex="-1"><a class="header-anchor" href="#配置是一幅描绘系统的蓝图" aria-hidden="true">#</a> 配置是一幅描绘系统的蓝图</h1><p>如果你尝试修改过 NixOS 的配置文件，你就会明白配置文件中书写的内容实际上是你希望下次生成的系统。我们相信这是广大 NixOS 新手的基本认知。</p><h2 id="中心化的配置文件带来管理的便捷" tabindex="-1"><a class="header-anchor" href="#中心化的配置文件带来管理的便捷" aria-hidden="true">#</a> 中心化的配置文件带来管理的便捷</h2><p>既然是根据配置文件生成系统，我们肯定希望配置文件是集中的，而不是零零散散的 dotfiles。它最好使用统一的语法描述，而不是 XML、YAML、TOML、json 等各种格式。而 NixOS 正是使用 Nix 语言来抹平这道沟壑。</p><p>Nix 文件就是使用 Nix 语言编写的源码文件，它们可以互相导入（就像常见的脚本一样），你可以将它们当作项目一样去组织。</p><h2 id="依赖计算" tabindex="-1"><a class="header-anchor" href="#依赖计算" aria-hidden="true">#</a> 依赖计算</h2><p>我们通常会在配置文件里自定义某个软件的选项，从而不自觉地引入了包。声明式配置带来的好处之一就是所有的包和依赖都是确定的，配置文件不再仅仅是单纯的源码，还是一个关系图。</p>',7),h=e("p",null,"因为配置使用了 Nix 语言，打包也使用了 Nix 语言，Nix 包管理器能够全程参与计算。我们将软件构建任务抽象成一个结点，软件构建往往会有其他依赖，若干结点构成了图，Nix 只需要保证这个关系图是有向无环的。",-1),l=e("div",{class:"hint-container tip"},[e("p",{class:"hint-container-title"},"提示"),e("p",null,"保证无环是为了让 Nix 能够有明确的构建顺序，使之能够并行构建，并且解决循环依赖的问题。")],-1),p=e("p",null,"在 NixOS 中你需要执行生成命令，才会重新计算依赖，生成新生代（新状态）。",-1);function x(f,m){const a=t("Mermaid");return n(),o("div",null,[c,s(a,{id:"mermaid-21",code:"eJxl0dFOwjAUBuB7n2Iv0BsfwESdCIoiOhVzwsVZV0pjN5quC7CnZ5zTQAm763f+tX9a7dGtsyK/yYbvHqxput0yE+Iue+CFQGfEWmGlfLvkFI0f43hlfL1Fr9JZDtqaUjLlRE8Q+goDpjaClbGq3bdB1ewj8mcw2KBQIe7AOga58aoLxsYeY+IJoLQME4IXwBB8GnkFXbsUpkP3UmK0Kdnb1W/vx5R2WijvNxeTGTiMjWcEH+cSDHPArjKBaU70GQ8VjU6TX1D2xt2mVID0KP+HOGtB+g39STj3A9XF+je9dqbFsWmJbXyeBeEf1z8AyaGFMw=="}),h,l,p])}const N=i(d,[["render",x],["__file","ConfigurationIsTheBlueprintOfTheSystem.html.vue"]]);export{N as default};
