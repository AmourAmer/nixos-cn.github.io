import{_ as o,X as t,Y as d,Z as a,$ as n,a0 as i,a2 as e,E as c}from"./framework-56285508.js";const r={},p=e(`<h1 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h1><h2 id="包管理" tabindex="-1"><a class="header-anchor" href="#包管理" aria-hidden="true">#</a> 包管理</h2><p>这一节我们会讨论如何为你的系统添加额外的包。NixOS 包管理的方式有两种：</p><ul><li><p>配置文件声明。你可以在配置文件为系统或用户声明需要安装的包，每次你重新生成系统，NixOS 都会确保本地包含了你指定的这些包。这是持久的。</p></li><li><p>非持久环境。使用 <code>nix-env</code> 管理软件包安装，升级与卸载。这种方式允许不同软件仓库频道版本的包共存。这也是非 root 用户唯一安装软件包的方式。</p></li></ul><h3 id="声明式包管理" tabindex="-1"><a class="header-anchor" href="#声明式包管理" aria-hidden="true">#</a> 声明式包管理</h3><p>在 <code>configuration.nix</code> 中， 提供用于声明系统环境包含的包的 <code>environment.systemPackages</code> 数组：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>environment<span class="token punctuation">.</span>systemPackages <span class="token operator">=</span> <span class="token punctuation">[</span> pkgs<span class="token punctuation">.</span>firefox <span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment"># 将来源于 pkgs(Nixpkgs) 的包安装到系统</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>== 配置文件并不是实时生效的== 。你需要运行 <code>sudo nixos-rebuild switch</code> 来生成当前配置文件描述的系统。</p>`,8),l={class:"hint-container note"},u=a("p",{class:"hint-container-title"},"依赖配置",-1),h={href:"https://nixos.org/manual/nixos/stable/options.html",target:"_blank",rel:"noopener noreferrer"},v=e(`<p>你可以使用以下命令获取在线包仓库中可用的软件包的列表：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ nix-env <span class="token parameter variable">-qaP</span> <span class="token string">&#39;*&#39;</span> <span class="token parameter variable">--description</span>
nixos.firefox   firefox-23.0   Mozilla Firefox - the browser, reloaded
<span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常会输出很多行可以获取的包的信息。第一列输出是属性名（例如<code>nixos.firefox</code>）。</p><div class="hint-container note"><p class="hint-container-title">前缀</p><p><code>nixos</code> 前缀表明当前包是从 <code>nixos</code> 频道获取的。</p></div><p>如果你想卸载这个包，修改配置后重新生成系统即可。</p><h3 id="定制软件包" tabindex="-1"><a class="header-anchor" href="#定制软件包" aria-hidden="true">#</a> 定制软件包</h3><p>一些软件包会提供一些禁用或启用功能，更改一些特性的选项。例如 Firefox 插件捆绑包（会额外提供一些诸如 Adobe Flash Player 的插件）会提供一个启用 Google Talk 的选项，如此配置便可以：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>nixpkgs<span class="token punctuation">.</span>config<span class="token punctuation">.</span>firefox<span class="token punctuation">.</span>enableGoogleTalkPlugin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">难以查询</p><p>遗憾的是，Nixpkgs 依然无法提供一种简易查询这些选项的方式。</p></div><p>除了高阶选项外，你还可以以几乎任意方式调整软件包，例如更改或禁用软件包的依赖项。例如，Nixpkgs 中的 Emacs 软件包默认依赖于 GTK 2。如果你想将其构建为使用 GTK 3 的软件包，可以按如下方式指定：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>environment<span class="token punctuation">.</span>systemPackages <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span>pkgs<span class="token punctuation">.</span>emacs<span class="token punctuation">.</span>override <span class="token punctuation">{</span> gtk <span class="token operator">=</span> pkgs<span class="token punctuation">.</span>gtk3<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们使用了 <code>override</code> 函数指定了用户定义的参数，意味着我们覆写了一部分原本的参数，构建的包也因此改变了。 让我们来细看这个语句，<code>gtk</code> 默认是接受 <code>pkgs.gtk2</code> 参数的，我们使用 <code>pkgs.gtk3</code> 作输入的时候，默认参数已经失效了，于是构建出来的包是依赖 GTK 3 的了。</p><div class="hint-container warning"><p class="hint-container-title">运算优先级</p><p>圆括号是必要的，因为在 Nix 语言中，列表构造优先级高于函数。如果不使用括号，列表将会认为它接收了两个元素。</p></div><p>我们还可以使用 <code>overrideAttrs</code> 函数做出更多定制。<code>override</code> 函数的机制是覆写了包输入函数的参数，而 <code>overrideAttrs</code> 允许覆写传递给 <code>mkDerivation</code> 的属性。如此你几乎能修改这个包的方方面面，甚至包括源码。如果你想覆写源码输入，可以这样做：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>environment<span class="token punctuation">.</span>systemPackages <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">(</span>pkgs<span class="token punctuation">.</span>emacs<span class="token punctuation">.</span>overrideAttrs <span class="token punctuation">(</span>oldAttrs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    name <span class="token operator">=</span> <span class="token string">&quot;emacs-25.0-pre&quot;</span><span class="token punctuation">;</span>
    src <span class="token operator">=</span> <span class="token url">/path/to/my/emacs/tree</span><span class="token punctuation">;</span>  <span class="token comment"># 你的源码目录</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，<code>pkgs.emacs</code> 被衍生出了一个重新调用 <code>stdenv.mkDerivation</code> 并替换了 <code>name</code> 和 <code>src</code> 属性的版本。然后 <code>overrideAttrs</code> 接收了这个衍生，成为了目前系统环境的 <code>emacs</code> 包。</p><h3 id="添加自定义包" tabindex="-1"><a class="header-anchor" href="#添加自定义包" aria-hidden="true">#</a> 添加自定义包</h3><h4 id="使用-nix-语言构建" tabindex="-1"><a class="header-anchor" href="#使用-nix-语言构建" aria-hidden="true">#</a> 使用 Nix 语言构建</h4><h4 id="使用预构建文件" tabindex="-1"><a class="header-anchor" href="#使用预构建文件" aria-hidden="true">#</a> 使用预构建文件</h4><p>大多数可执行文件都不能在 NixOS 上直接工作，但是将依赖一起打包的容器格式就可以，常见的容器格式有 <code>flatpaks</code> 和 <code>AppImages</code> 等。</p><h3 id="非持久包管理-ad-hoc-包管理" tabindex="-1"><a class="header-anchor" href="#非持久包管理-ad-hoc-包管理" aria-hidden="true">#</a> 非持久包管理（Ad-Hoc 包管理）</h3><p>这种方式不持久是相对于声明式包管理的。声明式包管理可以保证系统的一致性和可复制性，所以是持久的。不过 Ad-Hoc 方式非常灵活。</p><div class="hint-container tip"><p class="hint-container-title">Ad-Hoc</p><p>这个词语的起源是拉丁语，意思是“为此”。它通常表示一种针对特定目的，问题或任务的解决方案，而不是一种可以适用于其他情况的通用解决方案。例如，一个政府为了解决一个具体问题而设立的委员会就是一个 ad-hoc 委员会。更宽松地说，它也可以意味着“自发的”，“未计划的”或“即兴的”。</p><p>在 nixos 中，Ad-Hoc 的意义是指可以在一个临时的 shell 环境中使用任何用 nix 打包的程序，而不需要永久地安装它。这样可以方便地创建和使用开发环境，而不影响系统的状态。</p></div><p>通过 <code>nix-env</code> 命令，你可以像常规发行版那样使用命令安装软件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-env <span class="token parameter variable">-iA</span> nixos.thunderbird
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果以 root 权限执行此语句，软件包将会被安装到 <code>/nix/var/nix/profiles/default</code>，并且对所有用户可见。如果你是普通用户，软件包将会安装到 <code>/nix/var/nix/profiles/per-user/username/profile</code>，并且仅对当前用户可见。<code>-A</code> 参数指定了软件包所属的属性，如果不带属性，直接匹配 <code>thunderbird</code> 速度会较慢，同时也可能匹配到多个名称相同的包，产生歧义。</p><p>假设我们需要更新的包来自于系统频道，我们可以先更新系统频道，然后重新安装或更新指定包：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-channel <span class="token parameter variable">--update</span> nixos  <span class="token comment"># 更新系统频道</span>
nix-env <span class="token parameter variable">-iA</span> nixos.thunderbird  <span class="token comment"># 再次安装时，此包会被替换为最新版</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的语句可以指定另外的频道，从而用不同频道的包去代替当前包。如果你想用当前包默认的来源升级包，尝试这样做：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-channel <span class="token parameter variable">--update</span> nixos
nix-env <span class="token parameter variable">-u</span> thunderbird
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想升级所有包，可以这样：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-env <span class="token parameter variable">-u</span> <span class="token string">&#39;*&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是需要注意， <mark>它并不会升级系统配置中描述的包</mark> ，那些包由 <code>nixos-rebuild switch</code> 命令管理。</p><p>如果你想更新那些包， <code>nixos-rebuild switch --upgrade</code> 即可，它会自动更新频道并更新系统生成。</p><p>如果你想卸载使用命令安装的包，使用以下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-env <span class="token parameter variable">-e</span> thunderbird
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此外，用户环境的状态是可以回滚的：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nix-env <span class="token parameter variable">--rollback</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,38),m={href:"https://nixos.org/manual/nix/unstable/command-ref/nix-env.html",target:"_blank",rel:"noopener noreferrer"},k=e(`<h2 id="用户管理" tabindex="-1"><a class="header-anchor" href="#用户管理" aria-hidden="true">#</a> 用户管理</h2><p>类似的，NixOS 支持声明式用户管理和命令行用户管理。</p><h3 id="声明式用户管理" tabindex="-1"><a class="header-anchor" href="#声明式用户管理" aria-hidden="true">#</a> 声明式用户管理</h3><p>我们以下面的例子说明声明式用户管理的大致细节：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>users<span class="token punctuation">.</span>users<span class="token punctuation">.</span>alice <span class="token operator">=</span> <span class="token punctuation">{</span>
  isNormalUser <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  home <span class="token operator">=</span> <span class="token string">&quot;/home/alice&quot;</span><span class="token punctuation">;</span>
  description <span class="token operator">=</span> <span class="token string">&quot;Alice Foobar&quot;</span><span class="token punctuation">;</span>
  extraGroups <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;wheel&quot;</span> <span class="token string">&quot;networkmanager&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
  openssh<span class="token punctuation">.</span>authorizedKeys<span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;ssh-dss AAAAB3Nza... alice@foobar&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据描述，该用户加入了 <code>wheel</code> 组，意味着它可以使用 <code>sudo</code> 命令提权，此外它还加入了 <code>networkmanager</code> 组，意味着该用户可以配置网络。不过这样创建出来的用户是没有初始密码的，你仍需要使用 <code>passwd</code> 命令为其分配密码， <mark>每次重新生成系统的时候不会影响到密码的状态</mark> 。对于 ssh 连接，你可以指定认证密钥，只要公钥与私钥匹配就能连接。</p>`,6),b=a("code",null,"users.mutableUsers",-1),x=a("code",null,"False",-1),g=a("code",null,"/etc/passwd",-1),f=a("code",null,"/etc/group",-1),_={href:"https://nixos.org/manual/nixos/stable/options.html#opt-users.users._name_.hashedPassword",target:"_blank",rel:"noopener noreferrer"},w=a("code",null,"hashedPassword",-1),A=e(`<p>用户 <code>uid</code> 是自动分配的，不过你也可以自行指定：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>uid <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>gid</code> 分配也是自动的，同样可以用户定义，也是类似的方法：</p><div class="language-nix line-numbers-mode" data-ext="nix"><pre class="language-nix"><code>users<span class="token punctuation">.</span>groups<span class="token punctuation">.</span>students<span class="token punctuation">.</span>gid <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="命令行式用户管理" tabindex="-1"><a class="header-anchor" href="#命令行式用户管理" aria-hidden="true">#</a> 命令行式用户管理</h3><p>创建一个名为 <code>alice</code> 的用户，<code>-m</code> 参数用于给该用户创建 <code>home</code> 目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">useradd</span> <span class="token parameter variable">-m</span> alice
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了让 nix 工具集可以为该用户所用，我们还需要给这个用户打开 login shell（加载用户配置的 shell）。这一步会把 <code>~/.nix-defexpr</code> 链接到该用户的目录，这样该用户才能使用 nix 的一系列命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">su</span> - alice <span class="token parameter variable">-c</span> <span class="token string">&quot;true&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们还需要为其分配密码，才能登录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">passwd</span> alice
Enter new UNIX password: ***
Retype new UNIX password: ***
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用 <code>userdel -r alice</code> 删除该用户，<code>-r</code> 参数用于移除该用户的 <code>home</code> 目录。此外还有 <code>usermod</code>，<code>groupadd</code>, <code>groupmod</code> 和 <code>groupdel</code> 可以使用。</p><h2 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统" aria-hidden="true">#</a> 文件系统</h2><h2 id="显示服务" tabindex="-1"><a class="header-anchor" href="#显示服务" aria-hidden="true">#</a> 显示服务</h2><h3 id="x11" tabindex="-1"><a class="header-anchor" href="#x11" aria-hidden="true">#</a> X11</h3><h3 id="wayland" tabindex="-1"><a class="header-anchor" href="#wayland" aria-hidden="true">#</a> Wayland</h3><h2 id="gpu-加速" tabindex="-1"><a class="header-anchor" href="#gpu-加速" aria-hidden="true">#</a> GPU 加速</h2><h2 id="桌面环境" tabindex="-1"><a class="header-anchor" href="#桌面环境" aria-hidden="true">#</a> 桌面环境</h2><h3 id="xfce" tabindex="-1"><a class="header-anchor" href="#xfce" aria-hidden="true">#</a> XFCE</h3><h3 id="gnome" tabindex="-1"><a class="header-anchor" href="#gnome" aria-hidden="true">#</a> GNOME</h3><h3 id="kde" tabindex="-1"><a class="header-anchor" href="#kde" aria-hidden="true">#</a> KDE</h3>`,21);function N(q,y){const s=c("ExternalLinkIcon");return t(),d("div",null,[p,a("div",l,[u,a("p",null,[n("对于某些包（例如依赖 D-Bus 或 systemd 服务注册的包），仅仅是安装还是不够的，我们需要为它们对系统进行一些配置。 你可以访问"),a("a",h,[n("选项列表"),i(s)]),n("来检索需要启用的 NixOS 模块。")])]),v,a("p",null,[n("你可以查阅 "),a("a",m,[n("nix-env 手册页"),i(s)]),n(" 获取更多信息。")]),k,a("p",null,[n("如果你设置 "),b,n(" 为 "),x,n(" ，"),g,n(" 与 "),f,n(" 目录的内容将与配置文件中描述的一致。例如，如果你从配置文件中删除了某位用户，然后重新生成系统，这个用户就真实消失了。同时通过命令行管理用户的方式将失效。不过你仍然可以通过设置用户的 "),a("a",_,[w,i(s)]),n(" 选项来分配密码。")]),A])}const E=o(r,[["render",N],["__file","configuration.html.vue"]]);export{E as default};
